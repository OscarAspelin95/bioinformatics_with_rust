<!DOCTYPE HTML>
<html lang="en" class="coal sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SIMD Vectorization - Bioinformatics with Rust</title>


        <!-- Custom HTML head -->
        <meta property="og:title" content="Bioinformatics With Rust" />
        <meta property="og:description" content="An introduction to using Rust for bioinformatic applications." />
        <meta property="og:image" content="" />
        <meta property="og:url"
            content="https://github.com/OscarAspelin95/bioinformatics_with_rust/blob/5fd7158379edf483d5b975aa40b8460cd4bc85d2/src/assets/rust-bio-gray.png" />
        <meta property="og:type" content="website" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/assets/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "coal";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bioinformatics with Rust</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/OscarAspelin95/bioinformatics_with_rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="simd-vectorization"><a class="header" href="#simd-vectorization">SIMD Vectorization</a></h1>
<p>Full disclosure - I'm not a computer science expert. Not even close actually. This will not be a heavy theoretical introduction. Rather, I will try to explain how SIMD can be used to significantly speed up bioinformatic analyses. Finally, I think these resources are valuable with respect to SIMD and Rust:</p>
<ul>
<li>SIMD on <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">Wikipedia</a>.</li>
<li>Rust <a href="https://doc.rust-lang.org/std/simd/index.html">std::simd</a>.</li>
<li>Rust <a href="https://doc.rust-lang.org/core/arch/index.html">core::arch</a>.</li>
<li>Rust <a href="https://doc.rust-lang.org/core/arch/x86_64/index.html">x86_64</a>.</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>SIMD (<strong>S</strong>ingle <strong>I</strong>nstruction <strong>M</strong>ultiple <strong>D</strong>ata) enables certain CPU instructions to be executed in parallel. In contrast to threads, SIMD is more primitive, low level and allows for a more restricted set of operations.</p>
<p>What makes SIMD a bit tricky is that it is architecture specific. Hence, the instruction sets we can use depend on what architecture our computer runs. We'll skip the details here, partially because it is out of scope in this book and partially because I personally don't know enough on this topic.</p>
<p>In the subsequent paragraphs, we assume we are running on the <code>x86_64</code> architecture.</p>
<h3 id="simd-registers-and-instruction-set-extensions"><a class="header" href="#simd-registers-and-instruction-set-extensions">SIMD Registers and Instruction Set Extensions</a></h3>
<p>SIMD operates on fixed-width registers. On <code>x86_64</code>, the main SIMD extensions are:</p>
<div class="table-wrapper"><table><thead><tr><th>Extension</th><th>Register width</th><th><code>u64</code> lanes</th></tr></thead><tbody>
<tr><td>SSE2</td><td>128-bit</td><td>2</td></tr>
<tr><td>AVX/AVX2</td><td>256-bit</td><td>4</td></tr>
<tr><td>AVX-512</td><td>512-bit</td><td>8</td></tr>
</tbody></table>
</div>
<p>Even though AVX-512 might be the widest and most powerful, it is not universally supported. SSE2 is effectively ubiquitous on <code>x86_64</code>.</p>
<h2 id="a-pragmatic-view"><a class="header" href="#a-pragmatic-view">A Pragmatic View</a></h2>
<p>Going back to the previous chapter, we constructed a relatively efficient algorithm for generating kmers from a nucleotide sequence. How can we make this algorithm even more efficient with SIMD?</p>
<p>First, let's look at some pseudo code, inspired by the previous chapter for processing the forward strand.</p>
<pre><code class="language-rust noplayground">
fn kmerize(kmer_size: usize, nt_string: &amp;[u8]) {
	
    let nbits = kmer_size &lt;&lt; 1;
    let mask: u64 = (1 &lt;&lt; nbits) - 1;

	// iterate over each nt.
    nt_string.iter().for_each(|nt_char| {
    	// encode
        let nt = LOOKUP[*nt_char as usize] as u64;
        
        // bit shift (add nt)
        storage = (storage &lt;&lt; 2 | nt) &amp; mask;
    
    });
}</code></pre>
<p>It is obvious that this function handles a single sequence. What if we could process multiple sequences at once? Conceptually (and with pseudo code) it could look something like this</p>
<pre><code class="language-rust noplayground">fn kmerize(kmer_size: usize, nt_strings: &amp;[&amp;[u8]]){
	let nbits = kmer_size &lt;&lt; 1;
    let mask: u64 = (1 &lt;&lt; nbits) - 1;
    
	let storage_simd = create_simd_vector[0_u64; nt_strings.len()];
	
	// assume all nt_string have equal length. 
	let seq_len = nt_strings[0].len();
	
	for i in 0..seq_len {
		let nt_simd = simd_vector::from(nt_strings.iter().map(|s: &amp;[u8]| s[i]));
		
		storage_simd = (storage_simd &lt;&lt; 2 | nt_simd) &amp; mask;
	}
}</code></pre>
<p>We start with an initial storage SIMD vector the same length as the number of sequences. This way, each sequence gets its own <code>slot</code>. In each iteration <code>i</code> we extract the <code>ith</code> nucleotide from every sequence, create a nucleotide SIMD vector and apply the bit shift in parallel. Schematically, it could look something like this:</p>
<pre><code class="language-rust noplayground">nt_strings = [b"ATCA", b"GTGA", b"TCGA"]

storage_simd = [0_u64, 0_u64, 0_u64]

for i in 0..4{
	// for i=0, we extract:
	// * the b'A' from b"ATCA"
	// * the b'G' from b"GTGA"
	// * the b'T' from b"TCGA".
	nt_simd = [0, 2, 3] = [0b00, 0b10, 0b11];
	storage_simd = ([0_u64, 0_u64, 0_u64] &lt;&lt; 2 | [0b00, 0b10, 0b11]) &amp; mask = [0b00, 0b10, 0b11]
	
	// for i=1, we extract:
	// * the b'T' from b"ATCA"
	// * the b'T' from b"GTGA"
	// * the b'C' from b"TCGA".
	nt_simd = [3, 3, 1] = [0b11, 0b11, 0b01];
	storage_simd = ([0b00, 0b11, 0b11] &lt;&lt; 2 | [0b11, 0b11, 0b01]) &amp; mask = [0b0011, 0b1011, 0b1101]
}</code></pre>
<p>Our implementation has a fundamental flaw. What if the sequences don't have the same length? We have to rethink our approach.</p>
<h2 id="chunking"><a class="header" href="#chunking">Chunking</a></h2>
<p>Instead of trying to process separate, unrelated sequences at once, what if we can process a single sequence at once?</p>
<p>What if we can cleverly chop our sequence into N equal size chunks (where N is the number of SIMD lanes available) and process them in parallel? We can, with some requirements:</p>
<ul>
<li>The sequence has to be reasonably long for this to make sense.</li>
<li>We have to handle cases where a sequence is not evenly divisible into exactly 8 chunks.</li>
</ul>
<p>We must first investigate how to chop our sequence. As an example, take the sequence <code>b"AAATTTCCC"</code>. With a kmer size of length 3, we want to generate</p>
<pre><code>AAA, AAT, ATT, TTT, TTC, TCC, CCC
</code></pre>
<p>Also, pretend we have 3 SIMD lanes available. We need to chop our sequence into 3 chunks, each of which can be processed in parallel. We must ensure that:</p>
<ul>
<li>Each chunk is longer than, or equal to the kmer size.</li>
<li>We have to handle the residual if the sequence cannot be exactly chunked into 3.</li>
</ul>
<p>The key is to generate chunks that overlap by <code>kmer_size - 1</code> nucleotides. A short motivation for this is that it generates our target kmers. The more nuanced motivation is the following - try chunking into non-overlapping chunks. This would yield <code>AAA</code>, <code>TTT</code> and <code>CCC</code>. Kmerizing these (k=3) would simply give <code>AAA</code>, <code>TTT</code> and <code>CCC</code>, which is fewer kmers than the <code>sequence_length - kmer_size + 1 = 9 - 3 + 1 = 7</code> kmers we listed above. One (kinda) correct way to chunk would be
<code>AAAT</code>, <code>ATTT</code> and <code>TTCC</code>, where each sub-sequence is overlapping by <code>kmer_size - 1 = 3 - 1 = 2</code>. Kmerizing these would give</p>
<pre><code>AAAT -&gt; AAA, AAT
ATTT -&gt; ATT, TTT
TTCC -&gt; TTC, TCC
</code></pre>
<p>Which is 6 out of the 7 kmers we wanted. We are missing one kmer because the last <code>C</code> was excluded from the chunking. But since we know this, we can easily generate the last kmer.</p>
<p>Regardless, with some clever maths (of which the formula I still find hard to derive) we can design our chunks and residual so that all kmers can be easily extracted.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h2>
<p>Assume we are running on <code>AVX-512</code>, which means we can have (at most) a 512-bit SIMD register. Since we use <code>u64</code> as storage for each kmer, we can have at most <code>512 / 64 = 8</code> SIMD lanes. If we chop our sequence into 8 equal-length chunks, we can process them in parallel and then handle the residual separately.</p>
<p>In practice though, one would typically use a crate that fully supports all of this out of the box. One example is <a href="https://docs.rs/simd-minimizers/latest/simd_minimizers/">simd-minimizers</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../main/advanced_topics/kmers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../main/kmers/building_a_reverse_index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../main/advanced_topics/kmers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../main/kmers/building_a_reverse_index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
