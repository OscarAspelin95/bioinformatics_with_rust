<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bit Shift Encoding - Bioinformatics with Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bioinformatics with Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bit-shift-encoding"><a class="header" href="#bit-shift-encoding">Bit Shift Encoding</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Our naive implementation works, but it is not very efficient because:</p>
<ul>
<li>We are using ASCII encoding for our bases, which takes up unecessary amounts of storage.</li>
<li>Using a iterative sliding window approach is not feasible for long sequences.</li>
</ul>
<p>To streamline our kmer generation function, we need to understand a bit about bit shifting and how computers interpret data. Computers are ridiculously fast at <a href="https://www.geeksforgeeks.org/dsa/all-about-bit-manipulation/">bitwise operations</a>. We won't cover the details in this book, but we'll go over the things we need in order for our kmer script to work properly.</p>
<p>A <em>left shift</em> is defined as an operation in which the bits in a binary number are shifted to the left. The most significant bit (leftmost) is lost, and the least significant bit (righmost) is shifted after which a zero is added.</p>
<ul>
<li>Example: 0010 &lt;&lt; 1 = 0100</li>
</ul>
<p>A <em>right shift</em> does the opposite.</p>
<ul>
<li>Example: 0100 &gt;&gt; 1 = 0010</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // Perform a left shift.
    assert_eq!(0b0010 &lt;&lt; 1, 0b0100);

    // Perform a right shift.
    assert_eq!(0b0100 &gt;&gt; 1, 0b0010);
}</code></pre></pre>
<p>In our case, we'll use 2-bit encoding for our nucleotides:</p>
<ul>
<li>A =&gt; 0b00</li>
<li>C =&gt; 0b01</li>
<li>G =&gt; 0b10</li>
<li>T =&gt; 0b11</li>
</ul>
<h2 id="choosing-storage-size"><a class="header" href="#choosing-storage-size">Choosing storage size</a></h2>
<p>We use unsigned integers to store our kmers. Remember that each nucleotide occupies two bits. The following types are available in Rust:</p>
<ul>
<li>u8 - can store kmers of max size 8/2 = 4.</li>
<li>u16 - can store kmers of max size 16/2 = 8.</li>
<li>u32 - can store kmers of max size 32 / 2 = 16.</li>
<li>u64 - can store kmers of max size 64/2 = 32.</li>
<li>u128 - can store kmers of max size 128/2 = 64.</li>
</ul>
<p>Can we store a kmer size of length 2 in, say a u16? Yes we can, but we'll waste space. In the following examples, we'll mostly deal with u32.</p>
<h2 id="handling-the-forward-strand"><a class="header" href="#handling-the-forward-strand">Handling the forward strand</a></h2>
<p>In order to insert a nucleotide, we need two things:</p>
<ul>
<li>A left shift by two to make room for the two new bits.</li>
<li>Insert the actual nucleotide, which is done with the "|" operator (BitOR).</li>
</ul>
<p>Hence, we add nucleotides from the <strong>right side</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut storage: u32 = 0b0;

    // Insert a T.
    storage = storage &lt;&lt; 2 | 0b11;
    assert_eq!(storage, 0b11);

    // Insert another T.
    storage = storage &lt;&lt; 2 | 0b11;
    assert_eq!(storage, 0b1111);

    // Insert a G.
    storage = storage &lt;&lt; 2 | 0b10;
    assert_eq!(storage, 0b111110);

    println!("{:032b}", storage);
}</code></pre></pre>
<p><strong>Note</strong> - it seems like new digits magically appear in our test cases. However, when we print the full u32, we see the leading zeros.</p>
<h4 id="what-actually-happens-is-something-more-like-this"><a class="header" href="#what-actually-happens-is-something-more-like-this">What actually happens is something more like this:</a></h4>
<ol>
<li>Add a "T":</li>
</ol>
<pre>
0b0[...]000000 << 2 = 0b0[...]000000 # shift by two nts, all zeros so not much happens.

    0b0[...]000000
    0b0[...]000011
    BitOR # insert the actual nt.
=   0b0[...]000011
</pre>
<ol start="2">
<li>Add another "T":</li>
</ol>
<pre>
0b0[...]000011 << 2 = 0b0[...]001100 # shift by two nts, move first "T" two bits.

    0b0[...]001100
    0b0[...]000011
    BitOR # insert the actual nt.
=   0b0[...]001111
</pre>
<ol start="3">
<li>Add a "G":</li>
</ol>
<pre>
0b0[...]001111 << 2 = 0b0[...]111100 # shift by two nts, move both "T"s two bits.

    0b0[...]111100
    0b0[...]000010
    BitOR # insert the actual nt.
=   0b0[...]111110
</pre>
<h3 id="handling-the-kmer-size"><a class="header" href="#handling-the-kmer-size">Handling the kmer size</a></h3>
<p>Our approach kinda works, but it has a fundamental flaw. We want our storage variable to only contain k nucleotides at one time, all other leading bits should be zero. As as example:</p>
<pre>
nt_string = "GTGT"
kmer_size = 2

# start
0b00000000

# insert G
0b00000010

# insert T
0b00001011

# When inserting the third nt G, we want this
# because our kmer size is 2.
0b00001110

If we don't account for the kmer size, we'd get
a kmer of size 3, which is not what we want.
0b00101110
</pre>
<p>We solve this by applying a bit-mask. The example below handles this, and also handles nucleotides that are not A/T/C/T by just ignoring those kmers.</p>
<pre><pre class="playground"><code class="language-rust edition2024">
<span class="boring">const LOOKUP: [u8; 256] = [
</span><span class="boring">    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">];
</span>

<span class="boring">fn decode(byte: u64) -&gt; char {
</span><span class="boring">    match byte {
</span><span class="boring">        0 =&gt; return 'A',
</span><span class="boring">        1 =&gt; return 'C',
</span><span class="boring">        2 =&gt; return 'G',
</span><span class="boring">        3 =&gt; return 'T',
</span><span class="boring">        _ =&gt; panic!("Invalid nucleotide."),
</span><span class="boring">    };
</span><span class="boring">}
</span>
// [...]

/// Print a u64 encoded nucleotide with some bit manipulation.
pub fn print_nt_string(kmer: u64, k: usize) {
    let mut result = String::with_capacity(k);
    for i in 0..k {
        // Shift to extract the 2 bits corresponding to the current nucleotide
        let shift = 2 * (k - i - 1);
        let bits = (kmer &gt;&gt; shift) &amp; 0b11;

        result.push(decode(bits));
    }
    println!("{}", result);
}

fn kmerize(kmer_size: usize, nt_string: &amp;[u8]){
    assert!(kmer_size &lt;= nt_string.len());

    // Forward related kmer stuff
    let mut storage: u64 = 0;

    // Mask for bits above kmer size.
    let nbits = kmer_size &lt;&lt; 1;
    let mask: u64 = (1 &lt;&lt; nbits) - 1;

    let mut valid_kmer_index: usize = 0;

    nt_string.iter().for_each(|nt_char| {
        // Forward kmer.
        let nt = LOOKUP[*nt_char as usize] as u64;

        if nt &gt;= 4 {
            valid_kmer_index = 0;
            storage = 0;
            return;
        }
        storage = (storage &lt;&lt; 2 | nt) &amp; mask;



        if valid_kmer_index &gt;= kmer_size - 1 {
            print_nt_string(storage, kmer_size);
        }

        valid_kmer_index += 1;
    });
}

fn main(){
    // We expect just one kmer.
    kmerize(5, b"AAAAA");

    // We expect no kmers.
    kmerize(5, b"AAAANAAAA");

    // We expect AAA, AAT, ATT, TTT.
    kmerize(3, b"AAATTT");
}
</code></pre></pre>
<h2 id="handling-the-reverse-complement"><a class="header" href="#handling-the-reverse-complement">Handling the reverse complement</a></h2>
<p>As mentioned in a previous section, we also need to handle the reverse complement. How do we do this in an efficient way? We insert the reverse complement from the left side instead of the right.</p>
<p>Lets go back to our example of "AGT". What we want to add is its reverse complement, which is "ACT". Remember that to reverse complement, we:</p>
<ul>
<li>
<p>Reverse the order of the sequence.</p>
<ul>
<li>Handled by the right shift, which will insert a nucleotide from the left side.</li>
</ul>
</li>
<li>
<p>Convert to the complementary base.</p>
<ul>
<li>Handled by complementing before inserting.</li>
</ul>
</li>
</ul>
<p><strong>NOTE</strong> - here we need to take the kmer size into consideration, otherwise we might run into problems. Assume we have the following storage:</p>
<pre>
0b00[...]00
</pre>
<p>and, as an example, we want to insert a "T" (0b00[...]11) from the left. We first need to shift our nucleotide to the most significant two bits:</p>
<pre>
0b00[...]11
    to
0b11[...]00
</pre>
<p>After this, we can use our BitOR:</p>
<pre>
    0b00[...]00 # storage (empty at the moment)
    0b11[...]00
    BitOR #
=   0b11[...]00 # storage now contains our "T".
</pre>
<h4 id="how-do-we-shift-our-two-nucleotide-bits-to-the-two-most-significant-bits"><a class="header" href="#how-do-we-shift-our-two-nucleotide-bits-to-the-two-most-significant-bits">How do we shift our two nucleotide bits to the two most significant bits?</a></h4>
<p>We use the following formula:</p>
<pre>
shift = (k-1) * 2 # where k is the kmer size.
nt = nt << shift # Shifts the two least significant bits to the most significant bits.
</pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let k: u8 = 4;

    let shift = ((k - 1) * 2) as usize;

    // Nucleotide "T".
    let mut nt = 0b11;

    nt = nt &lt;&lt; shift;

    println!("{:08b}", nt);
}</code></pre></pre>
<p>With a kmer size of 4, we get 0b11000000. In our case, the value (k-1) * 2 equals 6, which means that we have shifted our nucletide 6 bits to the left.</p>
<p>This is our final implementation of handling reverse complements:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut storage: u32 = 0b0;

    // Use kmer size 3 to exactly fit our three nucleotides
    // In the least significant bits.
    let k: u32 = 3;

    let forward = b"AGT";

    let shift: u32 = (k - 1) * 2;

    forward.iter().for_each(|nt| {
        let nt_encoded = match nt {
            b'A' =&gt; 0 as u32,
            b'C' =&gt; 1 as u32,
            b'G' =&gt; 2 as u32,
            b'T' =&gt; 3 as u32,
            _ =&gt; panic!(""),
        };
        // Use 3 - nt_encoded to get the reverse base.
        storage = storage &gt;&gt; 2 | (3 - nt_encoded) &lt;&lt; shift;
    });

    // Print the full u32-bit.
    println!("{:032b}", &amp;storage);
}</code></pre></pre>
<p>Run the code and inspect the result. Our output is:</p>
<pre>
00 [...] 00 01 11
         A  C  T

</pre>
<p>Which is the reverse complement of "AGT", inserted in the correct order.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">
<span class="boring">const LOOKUP: [u8; 256] = [
</span><span class="boring">    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 0, 4, 1, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
</span><span class="boring">];
</span>

<span class="boring">fn decode(byte: u64) -&gt; char {
</span><span class="boring">    match byte {
</span><span class="boring">        0 =&gt; return 'A',
</span><span class="boring">        1 =&gt; return 'C',
</span><span class="boring">        2 =&gt; return 'G',
</span><span class="boring">        3 =&gt; return 'T',
</span><span class="boring">        _ =&gt; panic!("Invalid nucleotide."),
</span><span class="boring">    };
</span><span class="boring">}
</span>
<span class="boring">/// Print a u64 encoded nucleotide with some bit manipulation.
</span><span class="boring">pub fn print_nt_string(kmer: u64, k: usize) {
</span><span class="boring">    let mut result = String::with_capacity(k);
</span><span class="boring">    for i in 0..k {
</span><span class="boring">        // Shift to extract the 2 bits corresponding to the current nucleotide
</span><span class="boring">        let shift = 2 * (k - i - 1);
</span><span class="boring">        let bits = (kmer &gt;&gt; shift) &amp; 0b11;
</span><span class="boring">
</span><span class="boring">        result.push(decode(bits));
</span><span class="boring">    }
</span><span class="boring">    println!("{}", result);
</span><span class="boring">}
</span>
// [...]

pub fn kmerize(k: usize, nt_string: &amp;[u8]){
    assert!(k &lt;= nt_string.len());

    // Forward related kmer stuff
    let mut kmer_forward: u64 = 0;

    let nbits = k &lt;&lt; 1;
    let mask: u64 = (1 &lt;&lt; nbits) - 1;

    // Reverse related kmer stuff.
    let mut kmer_reverse: u64 = 0;
    let shift = ((k - 1) * 2) as u64;

    let mut valid_kmer_index: usize = 0;

    nt_string.iter().for_each(|nt_char| {
        // Forward kmer.
        let nt = LOOKUP[*nt_char as usize] as u64;

        if nt &gt;= 4 {
            valid_kmer_index = 0;
            kmer_forward = 0;
            kmer_reverse = 0;
            return;
        }
        // Forward kmer.
        kmer_forward = (kmer_forward &lt;&lt; 2 | nt) &amp; mask;

        // Reverse kmer.
        let nt_rev = 3 - nt;
        kmer_reverse = kmer_reverse &gt;&gt; 2 | nt_rev &lt;&lt; shift;

        if valid_kmer_index &gt;= k - 1 {
            let canonical = match kmer_forward &lt; kmer_reverse {
                true =&gt; kmer_forward,
                false =&gt; kmer_reverse,
            };

            print_nt_string(canonical, k);
        }

        valid_kmer_index += 1;
    });

}

fn main(){
    kmerize(5, b"AAAAAA");
    kmerize(5, b"TTTTTT");
    kmerize(5, b"AAAANTTTT");
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../main/kmers/2_naive_implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../main/kmers/4_simd_vectorization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../main/kmers/2_naive_implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../main/kmers/4_simd_vectorization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
