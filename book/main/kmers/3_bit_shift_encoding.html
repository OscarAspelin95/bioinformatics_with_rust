<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bit Shift Encoding - Bioinformatics with Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bioinformatics with Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bit-shift-encoding"><a class="header" href="#bit-shift-encoding">Bit Shift Encoding</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Our naive implementation works, but it is not very efficient because:</p>
<ul>
<li>We are using ASCII encoding for our bases, which takes up unecessary amounts of storage.</li>
<li>Using a iterative sliding window approach is not feasible for long sequences.</li>
</ul>
<p>To streamline our kmer generation function, we need to understand a bit about bit shifting and how computers interpret data. Computers are ridiculously fast at <a href="https://www.geeksforgeeks.org/dsa/all-about-bit-manipulation/">bitwise operations</a>. We won't cover the details in this book, but we'll go over the things we need in order for our kmer script to work properly.</p>
<p>A <em>left shift</em> is defined as an operation in which the bits in a binary number are shifted to the left. The most significant bit (leftmost) is lost, and the least significant bit (righmost) is shifted after which a zero is added.</p>
<ul>
<li>Example: 0010 &lt;&lt; 1 = 0100</li>
</ul>
<p>A <em>right shift</em> does the opposite.</p>
<ul>
<li>Example: 0100 &gt;&gt; 1 = 0010</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // Perform a left shift.
    assert_eq!(0b0010 &lt;&lt; 1, 0b0100);

    // Perform a right shift.
    assert_eq!(0b0100 &gt;&gt; 1, 0b0010);
}</code></pre></pre>
<p>In our case, we'll use 2-bit encoding for our nucleotides:</p>
<ul>
<li>A =&gt; 0b00</li>
<li>C =&gt; 0b01</li>
<li>G =&gt; 0b10</li>
<li>T =&gt; 0b11</li>
</ul>
<h2 id="choosing-storage-size"><a class="header" href="#choosing-storage-size">Choosing storage size</a></h2>
<p>We use unsigned integers to store our kmers. Remember that each nucleotide occupies two bits. The following types are available in Rust:</p>
<ul>
<li>u8 - can store kmers of max size 8/2 = 4.</li>
<li>u16 - can store kmers of max size 16/2 = 8.</li>
<li>u32 - can store kmers of max size 32 / 2 = 16.</li>
<li>u64 - can store kmers of max size 64/2 = 32.</li>
<li>u128 - can store kmers of max size 128/2 = 64.</li>
</ul>
<p>Can we store a kmer size of length 2 in, say a u16? Yes we can, but we'll waste space. In the following examples, we'll mostly deal with u32.</p>
<h2 id="handling-the-forward-strand"><a class="header" href="#handling-the-forward-strand">Handling the forward strand</a></h2>
<p>In order to insert a nucleotide, we need two things:</p>
<ul>
<li>A left shift by two to make room for the two new bits.</li>
<li>Insert the actual nucleotide, which is done with the "|" operator (BitOR).</li>
</ul>
<p>Hence, we add nucleotides from the <strong>right side</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut storage: u32 = 0b0;

    // Insert a T.
    storage = storage &lt;&lt; 2 | 0b11;
    assert_eq!(storage, 0b11);

    // Insert another T.
    storage = storage &lt;&lt; 2 | 0b11;
    assert_eq!(storage, 0b1111);

    // Insert a G.
    storage = storage &lt;&lt; 2 | 0b10;
    assert_eq!(storage, 0b111110);

    println!("{:032b}", storage);
}</code></pre></pre>
<p><strong>Note</strong> - it seems like new digits magically appear in our example above. However, when we print the full u32, we see the leading zeros.</p>
<h4 id="what-actually-happens-is-something-more-like-this"><a class="header" href="#what-actually-happens-is-something-more-like-this">What actually happens is something more like this:</a></h4>
<ol>
<li>Add a "T":</li>
</ol>
<pre>
0b0[...]000000 << 2 = 0b0[...]000000 # shift by two nts, all zeros so not much happens.

    0b0[...]000000
    0b0[...]000011
    BitOR # insert the actual nt.
=   0b0[...]000011
</pre>
<ol start="2">
<li>Add another "T":</li>
</ol>
<pre>
0b0[...]000011 << 2 = 0b0[...]001100 # shift by two nts, move first "T" two bits.

    0b0[...]001100
    0b0[...]000011
    BitOR # insert the actual nt.
=   0b0[...]001111
</pre>
<ol start="3">
<li>Add a "G":</li>
</ol>
<pre>
0b0[...]001111 << 2 = 0b0[...]111100 # shift by two nts, move both "T"s two bits.

    0b0[...]111100
    0b0[...]000010
    BitOR # insert the actual nt.
=   0b0[...]111110
</pre>
<h2 id="handling-the-reverse-complement"><a class="header" href="#handling-the-reverse-complement">Handling the reverse complement</a></h2>
<p>As mentioned in a previous section, we also need to handle the reverse complement. How do we do this in an efficient way? We insert the reverse complement from the left side instead of the right.</p>
<p>Lets go back to our example of "AGT". What we want to add is its reverse complement, which is "ACT". Remember that to reverse complement, we:</p>
<ul>
<li>
<p>Reverse the order of the sequence.</p>
<ul>
<li>Handled by the right shift, which will insert a nucleotide from the left side.</li>
</ul>
</li>
<li>
<p>Convert to the complementary base.</p>
<ul>
<li>Handled by complementing before inserting.</li>
</ul>
</li>
</ul>
<p><strong>NOTE</strong> - here we need to take the kmer size into consideration, otherwise we might run into problems. Assume we have the following storage:</p>
<pre>
0b00[...]00
</pre>
<p>and, as an example, we want to insert a "T" (0b00[...]11) from the left. We first need to shift our nucleotide to the most significant two bits:</p>
<pre>
0b00[...]11
    to
0b11[...]00
</pre>
<p>After this, we can use our BitOR:</p>
<pre>
    0b00[...]00 # storage (empty at the moment)
    0b11[...]00
    BitOR #
=   0b11[...]00 # storage now contains our "T".
</pre>
<h4 id="how-do-we-shift-our-two-nucleotide-bits-to-the-two-most-significant-bits"><a class="header" href="#how-do-we-shift-our-two-nucleotide-bits-to-the-two-most-significant-bits">How do we shift our two nucleotide bits to the two most significant bits?</a></h4>
<p>We use the following formula:</p>
<pre>
shift = (k-1) * 2 # where k is the kmer size.
nt = nt << shift # Shifts the two least significant bits to the most significant bits.
</pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let k: u8 = 4;

    let shift = ((k - 1) * 2) as usize;

    // Nucleotide "T".
    let mut nt = 0b11;

    nt = nt &lt;&lt; shift;

    println!("{:08b}", nt);
}</code></pre></pre>
<p>With a kmer size of 4, we get 0b11000000. In our case, the value (k-1) * 2 equals 6, which means that we have shifted our nucletide 6 bits to the left.</p>
<p>This is our final implementation of handling reverse complements:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut storage: u32 = 0b0;

    // Use kmer size 3 to exactly fit our three nucleotides
    // In the least significant bits.
    let k: u32 = 3;

    let forward = b"AGT";

    let shift: u32 = (k - 1) * 2;

    forward.iter().for_each(|nt| {
        let nt_encoded = match nt {
            b'A' =&gt; 0 as u32,
            b'C' =&gt; 1 as u32,
            b'G' =&gt; 2 as u32,
            b'T' =&gt; 3 as u32,
            _ =&gt; panic!(""),
        };
        // Use 3 - nt_encoded to get the reverse base.
        storage = storage &gt;&gt; 2 | (3 - nt_encoded) &lt;&lt; shift;
    });

    // Print the full u32-bit.
    println!("{:032b}", &amp;storage);
}</code></pre></pre>
<p>Run the code and inspect the result. Our output is:</p>
<pre>
00 [...] 00 01 11
         A  C  T

</pre>
<p>Which is the reverse complement of "AGT", inserted in the correct order.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">fn encode(nt: &amp;u8) -&gt; u64 {
    match nt {
        b'A' =&gt; 0,
        b'C' =&gt; 1,
        b'G' =&gt; 2,
        b'T' =&gt; 3,
        _ =&gt; panic!("invalid nt {nt}"),
    }
}

fn decode(nt: &amp;u64) -&gt; u8 {
    match nt {
        0 =&gt; b'A',
        1 =&gt; b'C',
        2 =&gt; b'G',
        3 =&gt; b'T',
        _ =&gt; panic!("Invalid nt {nt}"),
    }
}

pub fn u64_kmer_to_string(kmer: &amp;u64, k: usize) -&gt; Vec&lt;u8&gt; {
    let mut bytes: Vec&lt;u8&gt; = vec![];

    let mask = 3;

    for i in 0..k {
        let val = kmer &gt;&gt; 2 * i;
        let val = val &amp; mask;
        bytes.push(decode(&amp;val));
    }

    let kmer_as_string = bytes.into_iter().rev().collect::&lt;Vec&lt;u8&gt;&gt;();

    return kmer_as_string;
}

fn kmerize(k: usize, nt_string: &amp;[u8]) -&gt; Vec&lt;u64&gt; {
    // Our kmer size cannot be larger then the sequence length.
    assert!(k &lt;= nt_string.len());

    // This is where we store our "rolling" kmer.
    let mut kmer: u64 = 0;

    // This is where we store the generated kmers.
    let mut kmers: Vec&lt;u64&gt; = Vec::new();

    // Iterate over each nucleotide in the sequence.
    for i in 0..nt_string.len() {
        // Convert ASCII to u64 (A/T/C/G to 0/1/2/3).
        let nt = encode(&amp;nt_string[i]);

        // Make room for nucleotide and then insert it.
        kmer = (kmer &lt;&lt; 2) | nt;

        // For the first k-1 nt insertions, we don't have a full kmer yet.
        // However, note that index i starts at 0 (0-based) whilst our kmer size
        // is 1-based (we don't count 0). Hence, when i &gt;= k-1, we have actually
        // inserted k nucleotides, which is our target.
        //
        // Example - a kmer_size of 3 means we push after inserting three nucleotides.
        // Since i starts at 0, we have inserted three nucleotides when i reaches 2 (index 0, 1 and 2).
        if i &gt;= k - 1 {
            kmers.push(kmer);
        }
    }

    return kmers;
}

fn kmerize_wrapper(kmer_size: usize, nt_string: &amp;[u8]) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
    let kmers = kmerize(kmer_size, nt_string);

    let kmers_as_strings: Vec&lt;Vec&lt;u8&gt;&gt; = kmers
        .iter()
        .map(|kmer| u64_kmer_to_string(kmer, kmer_size))
        .collect();

    return kmers_as_strings;
}
fn main() {
    let kmers = kmerize_wrapper(4, b"ATCGATCG");
    let formatted_kmers: Vec&lt;&amp;[u8]&gt; = kmers.iter().map(|kmer| kmer.as_slice()).collect();
    assert_eq!(
        formatted_kmers,
        vec![b"ATCG", b"TCGA", b"CGAT", b"GATC", b"ATCG"]
    );
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../main/kmers/2_naive_implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../main/kmers/4_simd_vectorization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../main/kmers/2_naive_implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../main/kmers/4_simd_vectorization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
